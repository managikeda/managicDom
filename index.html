<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="content-language" content="ja">
  <!-- 「managic」をローカルファイルへマッピング -->
  <!-- <script type="importmap">
  {
    "imports": {
      "managic": "./managic_dom.js"
    }
  }
  </script> -->
  <style> body { margin:0; background-color: #333; } </style>
</head>
<body>
  <div id="managic-stage"></div>
  <script type="module">
    // import { Core, Scene, FrameOverlay, Sprite, Label, loadGoogleFont, TileMap, Rect, Circle } from 'managic';
    import { Core, Scene, Sprite, Label, loadGoogleFont, TileMap, Rect, Circle } from './managic_dom.js';
    import { FrameWindow, CharSprite, UIButton, LabelArea, StatusBar, FrameOverlay, AnimatedCover, Particle, LoadingScene } from './managic_ui.js';

    // --- google fontをプリロード ---
    const FONTS = [
      ['Zen Kaku Gothic New', { weights:'100..900', italic:false }],
      ['Dela Gothic One',     { weights:[400],      italic:false }],
      ['Nico Moji',           { weights:[400],      italic:false }],
      // Zen Maru Gothic は離散ウェイト（300/400/500/700/900）
      ['Zen Maru Gothic',     { weights:[300,400,500,700,900], italic:false }],
      ['Shippori Mincho',     { weights:'400..900', italic:false }],
      ['Hachi Maru Pop',      { weights:[400],      italic:false }],
      ['Rampart One',         { weights:[400],      italic:false }],
      ['DotGothic16',         { weights:[400],      italic:false }],
      ['Potta One',           { weights:[400],      italic:false }],
    ];

    Promise.all(FONTS.map(([fam,opt]) => loadGoogleFont(fam,opt).then(()=>console.log(`${fam} loaded`))))
      .then(()=>{
        console.log('All fonts loaded');
      })
      .catch(e=>{ console.log('Font load error: '+(e&&e.message?e.message:e)); });

    const core = new Core(768, 576);//480, 320
    core.fps = 30;
    core.preload([
        './image/player.png',
        './image/chara1.png',
        './image/chara3.png',
        './image/map1.png'
    ]);

    core.addEventListener('load', () => {

      const createTitleScene = () => {
        const scene = new Scene();
        scene.backgroundColor = '#aaa';

        // 16x16 タイル、20x15 マップ
        // const map = new TileMap(16, 16, 30, 20);
        // scene.addChild(map);

        // // レイヤー追加
        // const ground = map.addLayer('ground', { tileset: core.assets['./image/map1.png'], visible:true, collidable:true });
        // let groundData = [
        //   [8,8,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24]
        // ];
        // const object = map.addLayer('object', { 
        //   tileset: core.assets['./image/map1.png'], 
        //   visible:true,
        //   collidable:true,
        //   // 例：100以上のタイルIDは固体とみなす
        //   // solid: (idx) => idx >= 100
        // });
        // let objectData = [
        //   [8,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,8],
        //   [8,0,1,2,3,4,5,6,7,8,0,0,0,12,13,14,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,17,18,19,20,21,22,23,24,0,0,0,28,29,30,0,0,0,0,0,0,0,0,0,0,0,0,,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8],
        //   [24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24]
        // ];
        // map.setLayerData(0, groundData);  // rows x cols 配列
        // map.setLayerData(1, objectData);

        // // 表示切替・透明度
        // map.setLayerVisible(1, true);
        // map.setLayerOpacity(1, 0.9);

        // 1) FrameWindow の利用
        const win = new FrameWindow(280, 160, 'glass');   // プリセット: 'panel' | 'dark' | 'glass' | 'accent'
        win.x = 24; win.y = 224;
        win.padding = { top:16, right:16, bottom:16, left:16 };
        scene.addChild(win);

        // 中身を入れる（content コンテナ内に配置される）
        const title = new Label('FrameWindow / パネル');
        title.font = 'bold 18px system-ui, sans-serif';
        win.content.addChild(title);

        const note = new Label('プリセット/パディング/サイズ変更が可能です。');
        note.y = 28;
        win.content.addChild(note);

        //サイズを変更してみる
        // win.setSize(320, 180).usePreset('accent');

        // 2) UIButton の利用（画像なし＝CSSテーマボタン）
        const btn1 = new UIButton(160, 40, { text: '長いボタンテキストです', maxFontSize: 20 });
        btn1.x = 60; btn1.y = 440;
        btn1.ontouchend = () => { 
          console.log('OK clicked');
          btn1.setText('クリックしてね');
          //core.replaceScene(createGameScene()); 
        };
        //btn1.setText('クリックしてね');
        //btn1._bg.tl.fadeTo(0, 100);
        //btn1.tl.scaleTo(0, 1, 60);
        scene.addChild(btn1);
        console.log(btn1.width, btn1.height);
        console.log(btn1.label.width, btn1.label.height);
        btn1.label.backgroundColor = 'rgba(255,255,255,.5)';

        // LabelArea
        const la = new LabelArea(420, 140, {
          font: '16px "Zen Kaku Gothic New", system-ui, sans-serif',
          fontSize: 16,      // 明示指定もOK（fontにpxが含まれていれば省略可）
          speed: 1,          // 2フレームごとに1文字
          text:
            'これは [b]複数行[/b] のテキスト表示と [u]タイプライタ[/u] のサンプルです。\n' +
            '「禁則処理」により、行頭に句読点が来ないように「簡易調整します」。' +
            '長い文章も自動で改行されます。'+
            'これは [b]複数行[/b] のテキスト表示と [u]タイプライタ[/u] のサンプルです。「禁則処理」により、行頭に句読点が来ないように簡易調整します。長い文章も自動で改行されます。'
        });
        la.x = 320; la.y = 340;
        scene.addChild(la);

        la.play(); // タイプ開始（speed>0の時だけ有効）

        //player(矢印キーで上下左右に移動)
        const player = new Sprite(32, 32);
        player.image = core.assets['./image/chara1.png'];
        player.x = 136;
        player.y = 200;
        player.speed = 5;
        player.animate([[0,0],[1,0],[2,0],[1,0]], 4, { loop:true, pingpong:false });
        scene.addChild(player);

        player.on('touchend', () => {
          la.skipAll();
          //la.setText('ほげほげほげほえええええええ');
          la.text = "いま、多くの人はまだ「近未来の話」としてAIを語っています。\n子どもが社会に出るころには、AIが仕事を奪うのではないか。入試や受験の形も変わるのではないか。そう考えると、不安も期待も「これから」の出来事として語りやすい。しかし現実は、もうずっと先に進んでいます。大規模言語モデル（LLM）と呼ばれるAIは、すでに学校教育や受験勉強の延長線上にある「知識の獲得」と「正解の再現」を、人間の比ではない規模と速度でこなしてしまう。それは未来ではなく、現在進行形の出来事です。";
          //core.replaceScene(createGameScene());
        });
        
        player.onenterframe = () => {
          
          if(core.input.left){
            player.x -= player.speed;
            // if(map.intersectEntity(player)){
            //   player.x += player.speed;
            // }
          }
          if(core.input.right){
            player.x += player.speed;
            // if(map.intersectEntity(player)){
            //   player.x -= player.speed;
            // }
          }
          if(core.input.up){
            player.y -= player.speed;
            // if(map.intersectEntity(player)){
            //   player.y += player.speed;
            // }
          }
          if(core.input.down){
            player.y += player.speed;
            // if(map.intersectEntity(player)){
            //   player.y -= player.speed;
            // }
          }

          // 単純な衝突チェック
          // if (map.intersectEntity(player)) {
          //   // 何かの衝突レイヤー上のタイルに当たっている
          //   console.log('衝突しました');
          // }

          // どのタイルに当たったか詳細
          // const info = map.intersectEntity(player, { details: true });
          // // info = { hit: boolean, tiles: [{layer, x, y, index}, ...] }
          // if (info.hit) {
          //   info.tiles.forEach(t => {
          //     // t.layer: レイヤー番号、t.x/t.y: タイル座標、t.index: タイルID
          //     console.log(t);
          //   });
          // }

          //レイヤーを指定して衝突チェック
          // if (map.intersectEntity(player, { layers:[0,1] })) {
          //   console.log('衝突しました1');
          // }
        };
      
        const label = new Label('HELLO ENCHANT DOM');
        label.text = 'HELLO ENCHANT DOM!!';
        label.color = '#fff';
        label.font = 'bold 32px system-ui';
        label.backgroundColor = 'rgba(0,0,0,0.5)';
        label.width = core.width;
        label.height = 32*1.2;
        label.x = 0;
        label.y = 150;
        label.textAlign = 'center';
        // label.ontouchend = () => { 
        //   label.rotation -= 15;
        // };
        scene.addChild(label);

          //左寄せで文字を重ねる
          const label2 = new Label('HELLO ENCHANT DOM');
          label2.text = 'HELLO ENC';
          label2.color = '#ff0';
          label2.font = 'bold 32px system-ui';
          label2.height = 32*1.2;
          label2.x = (label.width-label.textWidth)/2;
          label2.y = 150;
          label2.textAlign = 'left';
          scene.addChild(label2);

        let y = 18+44;
        // const mk=(text, css, color='#f5f7ff')=>{
        //   const lb=new Label(text); lb.font=css; lb.color=color; lb.moveTo(20,y); scene.addChild(lb); y+=44;
        //   lb.width = core.width;
        //   lb.textAlign = 'center';
        // };

        // mk('ぜんかくゴシック New（太さ900 / 28px）', '900 28px "Zen Kaku Gothic New", system-ui, sans-serif');
        // mk('デラゴシック One（太さ400 / 32px）', '400 32px "Dela Gothic One", system-ui, sans-serif', '#ffeb3b');

        // // Nico Moji（英字ほぼ無し → 日本語表示で確認）
        // mk('ニコもじ', '400 32px "Nico Moji", system-ui, sans-serif', '#00e5ff');

        // // Zen Maru Gothic（離散ウェイト）
        // mk('ぜんまるゴシック（太さ500 / 28px）', '900 28px "Zen Maru Gothic", system-ui, sans-serif', '#ffd2d2');

        // mk('しっぽり明朝（太さ600 / 24px）', '400 24px "Shippori Mincho", serif', '#e0f7fa');
        // mk('はちまるポップ（太さ400 / 28px）', '400 28px "Hachi Maru Pop", system-ui, sans-serif', '#fbcffb');
        // mk('ランパート One（太さ400 / 30px）', '400 30px "Rampart One", system-ui, sans-serif', '#b2ff59');
        // mk('ドットゴシック16（太さ400 / 24px）', '400 24px "DotGothic16", monospace', '#cfd8dc');
        // mk('ポッタ One（太さ400 / 30px）', '400 30px "Potta One", system-ui, sans-serif', '#ffd54f');

        // textWidth sample（JPグリフで測定）
        const s=new Label('にほんごテキスト幅の計測'); s.font='600 40px "Zen Maru Gothic", system-ui, sans-serif'; s.moveTo(20,y+8); scene.addChild(s);
        const w=new Label('textWidth: '+s.textWidth+' px'); w.font='14px system-ui, sans-serif'; w.color='#ccc'; w.moveTo(20,y+58); scene.addChild(w);
        // s.fontSize = 40;
        // s.fontWeight = 900;
        s.ontouchstart = () => {
          s.font = '400 40px "Hachi Maru Pop", system-ui, sans-serif';
          s.color = '#ffeb3b';
        };
      
        
        const sprite = new Sprite(32, 32);
        sprite.image = core.assets['./image/chara3.png'];
        sprite.x = 196;
        sprite.y = 200;
        //sprite.animate([1,2,1], 6, { loop: true, pingpong: true });
        sprite.animate([[0,0],[1,1],[2,2],[1,1]], 4, { loop:true, pingpong:false });
        scene.addChild(sprite);

        sprite.ontouchstart = () => {
          sprite.stopAnimation();
        };
        sprite.onenterframe = () => {
          if(sprite.intersect(player)){
            sprite.x += player.speed;
            //player.x -= player.speed;
          }
        };

        // const lbl2 = new Label('Score');
        // await lbl2.useGoogleFont('Bangers'); // 内部で load → family セット → autosize
        // scene.addChild(lbl2);

        // 矩形
        const block = new Rect(48, 16, {
          fillColor: '#4caf50',
          strokeColor: '#2e7d32',
          strokeWidth: 2,
          cornerRadius: 4
        });
        block.moveTo(220, 130);
        scene.addChild(block);

        // 円
        const ball = new Circle(24, {
          fillColor: '#ffc107',
          strokeColor: '#ff9800',
          strokeWidth: 2
        });
        ball.moveTo(120, 100);
        scene.addChild(ball);

        // ふつうの Sprite/Entity と同様に、tl や intersect が使えます
        ball.tl.moveBy(100, 0, 30, 'easeOutQuad').moveBy(-100, 0, 30, 'easeInQuad').loop();

        // 当たり判定（AABB）
        ball.onenterframe = () => {
          if (ball.intersect(block)) { console.log('ヒット'); }
        };


        scene.on('touchend', () => {
          //次のステージで使う画像を事前に読み込む
          // core.prefetch(['./image/chara2.png', './image/chara5.png']).then(()=>{
          //   console.log('prefetch done');
          //   core.replaceScene(createGameScene());
          // });
          // LoadingSceneを使った追加ロード
          core.replaceScene(new LoadingScene({
            files: [
              './image/chara2.png',
              './image/chara5.png',
              './assets/bg/bg_forest_elf.png',
              './assets/bg/bg_dangeon01.png',
              './assets/bg/bg_dangeon02.png',
              './assets/bg/bg_forestMakai.png',
              './assets/chara/chara_elfRanger_default.png',
              './assets/chara/chara_elfRanger_smile.png',
              './assets/chara/chara_humKnight_default.png',
              './assets/chara/chara_behimos_default.png',
            ],
            next: createGameScene, // 文字列 or (core)=>Scene or Scene
            label: 'Now Loading...',
            barWidth: 320,
            barColor: '#76FF03'
          }));
          // core.replaceScene(createGameScene());
        });
        return scene;
      };

      const createGameScene = () => {
        const scene = new Scene();
        scene.backgroundColor = '#888';

        const overlay = new FrameOverlay('arcade');
        overlay.x = 0; overlay.y = 0;
        scene.addChild(overlay);

        // パーツ追加（自動配置なし → 自分で座標指定）
        const logo = new Label('MY GAME');
        logo.font = 'bold 20px system-ui';
        logo.color = '#fff';
        overlay.addPart(logo);
        logo.x = 12;
        logo.y = 8;

        // 9-slice 画像フレーム
        // frame.useImageFrame('./frame.png', 24, 'stretch');

        //背景イメージ
        const bg = new Sprite(1536, 1023);//832, 1216
        bg.image = core.assets['./assets/bg/bg_forestMakai.png'];
        bg.y = -1023*0.2;
        bg.x = -1536*0.2;
        bg.scaleX = 0.6;
        bg.scaleY = 0.6;
        scene.addChild(bg);

        //キャラクターイメージ
        // const charaimage = new Sprite(1024, 1536);//832, 1216
        // charaimage.image = core.assets['./image/sd/char_behimos_default.png'];
        // charaimage.x = -100;
        // charaimage.y = -400;
        // charaimage.scaleX = 0.5;
        // charaimage.scaleY = 0.5;
        // scene.addChild(charaimage);

        const chara = new CharSprite('behimos', { baseDir:'./assets/chara', width:512, height:768, fit:true });
        chara.x = core.width/2-chara.width/2; chara.y = 0;
        scene.addChild(chara);
        chara.body.ontouchend = (e) => {
          
        };

        const player = new Sprite(32, 32);
        player.image = core.assets['./image/chara1.png'];
        player.x = 130;
        player.y = 15//200;
      //player.moveTo(136, 200);
    //   player.frames = [[0,0],[1,0],[2,0],[0,0],[1,0],[2,0],[0,1],[1,1],[2,1],[0,1],[1,1],[2,1],[0,2],[1,2],[2,2],[0,2],[1,2],[2,2]];
    //   let t = 0;
    //   scene.on('enterframe', ()=>{ player.frame = player.frames[t++ % player.frames.length]; });
        player.onenterframe = () => { 
        player.frame = player.age % 3;
        player.speed =  5;
        //player.x += 1;

        if(core.input.left){
          player.x -= player.speed;
        }
        if(core.input.right){
          player.x += player.speed; 
        }
        if(core.input.up){
          player.y -= player.speed; 
        }
        if(core.input.down){
          player.y += player.speed; 
        }
      };
      scene.addChild(player);
      player.ontouchend = (e) => {
        
        // const ac = new AnimatedCover();
        // ac.play('blink', {color:'rgba(255,255,255,1)', times: 4 });
        //hpBar.setValue(85, true);
        hpBar.addValue(-15, true);
        life.addValue(1, true);
        //chara.setDiff('smile');
      };

      const enemy = new Sprite(32, 32);
      enemy.image = core.assets['./image/chara2.png'];
      enemy.x = 180;
      enemy.y = 15;
      scene.addChild(enemy);
      enemy.ontouchend = () => {
        chara.showEmotion('💡', { anim:'pop' });
        chara.animShake(8, 6);
        const ac = new AnimatedCover();
        ac.play('darken', { to: 1, frames: 20, keep: true, autoRemove:false });
        //AnimatedCover.play('hit', { frames: 12, peak: 0.7 });
      };

      const enemy2 = new Sprite(32, 32);
      enemy2.image = core.assets['./image/chara5.png'];
      enemy2.x = 230;
      enemy2.y = 15;
      scene.addChild(enemy2);

      enemy2.ontouchend = () => {
        scene.tl.delay(5).then(()=> chara.animSlideInTop())
        .delay(30).then(()=> chara.animAttack())
        .delay(30).then(()=> chara.animDamaged())
        .delay(30).then(()=> chara.animSlideOutTop(80, 18));
        //画像を追加読み込みして切り替え
        // core.prefetch(['./image/chara6.png']).then(()=>{
        //   console.log('prefetch done');
        //   enemy2.image = core.assets['./image/chara6.png'];
        // });
      };

      scene.onenterframe = () => {
        if (player.intersect(enemy)) {
          player.x -= 1;
          enemy.x += 1;
          //console.log('intersect');
        }
        if(player.within(enemy, 40)){
          console.log('within');
        }
        if(player.hitTest(100,100)){
          console.log('hitTest');
        }
      };

      // player.tl
      //   .moveBy(200, 0, 30, 'easeOutQuad').and()
      //   .rotateTo(320, 30, 'easeInOutQuad')
      //   .moveBy(-200, 0, 30, 'easeInQuad').and()
      //   .rotateTo(-720, 30, 'easeInOutQuad')
      //   .moveBy(200, 100, 30, 'easeInCubic').and().fadeTo(0.5, 30, 'easeInOutQuad')
      //   .moveBy(-200, -100, 30, 'easeOutCubic').and().fadeTo(1, 30, 'easeInCubic')
      //   .moveBy(0, 200, 30, 'easeInOutCubic')
      //   .moveBy(0, -200, 30, 'easeInOutQuad')
      //   .loop();

      // 1) FrameWindow の利用
      const win = new FrameWindow(core.width-48, 200, 'panel');   // プリセット: 'panel' | 'dark' | 'glass' | 'accent'
      win.x = 24; win.y = core.height-224;
      win.padding = { top:16, right:16, bottom:16, left:16 };
      scene.addChild(win);

      // LabelArea
      const la = new LabelArea(core.width-88, 140, {
          font: '16px "Zen Kaku Gothic New", system-ui, sans-serif',
          fontSize: 24,      // 明示指定もOK（fontにpxが含まれていれば省略可）
          speed: 1,          // 2フレームごとに1文字
          text:
            '……何者だ。森に足を踏み入れる者の気配を見逃すと思ったか？\n' +
            'ここは私たちの棲み処、血脈より深く繋がれた大樹の加護のもとにある。獣であれ人であれ、理由なく立ち入れば、この森そのものが牙を剥くことを忘れるな。\n'
        });
        la.x = 10; la.y = 10;
        win.content.addChild(la);
        la.ontouchend = () => {
          console.log('ontouchend');
          la.setText('刃を抜くつもりはない……まだな。だが、お前が友か敵か、自然を敬う心を持つのかどうか、それを見極めるのは今この瞬間だ。\n' +
            '――答えろ。なぜ、この森に来た？');
        };


        // 1) HPゲージ
        const hpBar = new StatusBar('gauge', {
          x: core.width-220-20, y: 16,
          width: 220, height: 18,
          label: 'HP',
          bgColor: '#222',
          barColor: '#e74c3c',
          radius: 8,
          showValue: true,
          max: 120, value: 120
        });
        scene.addChild(hpBar);

        // ダメージを受けた
        // hpBar.setValue(85, true);   // アニメ付きで 85/120 に
        // // 回復
        // hpBar.addValue(+10, true);  // 95/120


        // 2) 残機やスタミナの“個数”表示
        const life = new StatusBar('tokens', {
          x: core.width-240, y: 46,
          label: 'LIFE',
          tokenSize: 22,
          symbolFilled: '🩷',
          symbolEmpty: '♡',
          spacing: 6,
          perRow: 10,        // 行折返ししたい場合
          max: 5, value: 3
        });
        scene.addChild(life);

        // 1つ消費
        //life.addValue(-1, true);    // 🩷🩷♡♡♡


        scene.on('touchend', (e) => {
          Particle.burst(scene, e.x, e.y, {
            type:'css',
            count: 24,
            speedMin: 2, speedMax: 6,
            spread: 360,
            gravity: 0.25,
            css: {
              shape: 'circle',
              size: 8 + (Math.random()*6|0),
              color: `hsl(${(Math.random()*360|0)}, 80%, 60%)`,
              shadow: '0 0 8px rgba(255,255,255,.5)'
            }
          }); 
          //core.pushScene(createPushedScene());
        });

        // frameを最前面へ（他のUI追加後）
        // frame.bringToFront();

        return scene;
      };

      const createPushedScene = () => {
        const scene = new Scene();
        scene.backgroundColor = 'rgba(0,0,0,0.2)';

        scene.on('touchend', () => {
          core.popScene();
        });
        return scene;
      };

      core.replaceScene(createTitleScene());
    });

    core.start();
  </script>
</body>
</html>
